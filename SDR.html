<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDR Radar - LPU5 Tactical</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --sb-collapsed: 70px;
            --sb-expanded: 280px;
            --bg-dark: #0a0a0a;
            --panel-bg: #1a1a1a;
            --panel-input-bg: #0f0f0f;
            --border: #282828;
            --border-color: #333;
            --accent: #2ecc71;
            --accent-blue: #3498db;
            --accent-yellow: #f39c12;
            --accent-red: #e74c3c;
            --text-main: #d0d0d0;
            --text-dim: #888;
        }

        body {
            margin: 0;
            padding-left: var(--sb-collapsed);
            background: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Courier New', monospace;
            transition: padding-left 0.3s ease;
        }

        .page-container {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        .page-title {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--text-main);
        }

        .page-title i {
            color: var(--accent-blue);
            margin-right: 10px;
        }

        .page-subtitle {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-top: 5px;
        }

        /* Panels */
        .panel-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .panel {
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-title {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .panel-title i {
            color: var(--accent-blue);
            margin-right: 8px;
        }

        .status-badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .status-online { background: rgba(46,204,113,0.2); color: #2ecc71; }
        .status-offline { background: rgba(231,76,60,0.2); color: #e74c3c; }
        .status-waiting { background: rgba(243,156,18,0.2); color: #f39c12; }

        /* Form elements */
        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px 12px;
            background: var(--panel-input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-main);
            font-family: inherit;
            font-size: 0.9rem;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        .btn:hover { opacity: 0.85; }
        .btn-primary { background: var(--accent-blue); color: #fff; }
        .btn-success { background: var(--accent); color: #000; }
        .btn-danger { background: var(--accent-red); color: #fff; }
        .btn-warning { background: var(--accent-yellow); color: #000; }

        .btn-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        /* SDR Waterfall + Spectrum display */
        .sdr-display-wrap {
            width: 100%;
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin-bottom: 10px;
            user-select: none;
        }

        /* Shared label bar above spectrum canvas */
        .sdr-mode-badge {
            position: absolute;
            top: 4px;
            right: 8px;
            font-size: 0.65rem;
            font-weight: bold;
            padding: 2px 7px;
            border-radius: 10px;
            background: rgba(46,204,113,0.2);
            color: #2ecc71;
            z-index: 2;
        }

        #spectrumCanvas, #waterfallCanvas {
            width: 100%;
            display: block;
            cursor: crosshair;
        }

        .sdr-freq-axis {
            display: flex;
            justify-content: space-between;
            padding: 2px 8px;
            font-size: 0.65rem;
            color: #555;
            background: #060606;
            border-top: 1px solid #1a1a1a;
        }

        .sdr-wf-label {
            font-size: 0.65rem;
            color: #444;
            padding: 2px 8px;
            background: #060606;
            border-top: 1px solid #111;
        }

        /* Colorscale bar */
        .sdr-colorscale {
            height: 8px;
            width: 100%;
            background: linear-gradient(to right,
                #000040 0%, #000080 10%, #0000c0 20%,
                #0060c0 30%, #00c0c0 45%, #00c000 55%,
                #c0c000 70%, #c06000 82%, #c00000 92%, #ff0000 100%);
            border-top: 1px solid #1a1a1a;
        }

        .spectrum-label {
            position: absolute;
            bottom: 5px;
            left: 10px;
            font-size: 0.7rem;
            color: #666;
        }

        /* Signal meter */
        .signal-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .signal-bar-container {
            flex: 1;
            height: 20px;
            background: #111;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            overflow: hidden;
        }

        .signal-bar {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .signal-value {
            min-width: 80px;
            text-align: right;
            font-weight: bold;
            font-size: 0.9rem;
        }

        /* Log table */
        .log-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .log-container table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
        }

        .log-container th,
        .log-container td {
            padding: 6px 10px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .log-container th {
            background: #111;
            color: var(--text-dim);
            font-weight: bold;
            position: sticky;
            top: 0;
        }

        .log-container tr:hover {
            background: rgba(52,152,219,0.1);
        }

        /* Triangulation map placeholder */
        .map-placeholder {
            width: 100%;
            height: 300px;
            background: #111;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            flex-direction: column;
            gap: 10px;
        }

        .map-placeholder i {
            font-size: 2rem;
            color: #333;
        }

        /* Info box */
        .info-box {
            background: rgba(52,152,219,0.1);
            border: 1px solid rgba(52,152,219,0.3);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .info-box i {
            color: var(--accent-blue);
            margin-right: 6px;
        }

        /* MQTT status */
        .mqtt-peers {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .peer-badge {
            padding: 4px 10px;
            background: rgba(46,204,113,0.15);
            border: 1px solid rgba(46,204,113,0.3);
            border-radius: 12px;
            font-size: 0.75rem;
            color: #2ecc71;
        }

        @media (max-width: 768px) {
            .panel-grid {
                grid-template-columns: 1fr;
            }
            .page-title {
                font-size: 1.3rem;
            }
            .page-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .btn-row {
                flex-wrap: wrap;
            }
            .btn {
                min-height: 44px;
                min-width: 44px;
            }
            .sdr-display-wrap canvas {
                width: 100% !important;
            }
            .log-container {
                overflow-x: auto;
            }
        }
        @media (max-width: 480px) {
            .page-subtitle {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>

<script src="load-global-nav.js"></script>

<div class="page-container">
    <!-- Header -->
    <div class="page-header">
        <div>
            <div class="page-title"><i class="fas fa-broadcast-tower"></i> LPU5 SDR Radar</div>
            <div class="page-subtitle">SDR Frequency Analysis &middot; Range Finder &middot; Cross-Bearing / Triangulation</div>
        </div>
        <div>
            <span class="status-badge status-waiting" id="sdrStatus">
                <i class="fas fa-circle"></i> Waiting for connection
            </span>
        </div>
    </div>

    <!-- Info box -->
    <div class="info-box">
        <i class="fas fa-info-circle"></i>
        <strong>LPU5 SDR Range Finder</strong> &ndash;
        This module uses RTL-SDR hardware via COM ports for frequency monitoring and
        signal strength analysis. Through cross-bearing with multiple devices (via MQTT),
        the approximate position of a signal source can be triangulated.
        <br><em>Requirements: RTL-SDR Stick, Raspberry Pi, MQTT Broker (Mosquitto).</em>
    </div>

    <!-- Top panels -->
    <div class="panel-grid">
        <!-- SDR Configuration -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title"><i class="fas fa-sliders-h"></i> SDR Configuration</div>
                <span class="status-badge status-offline" id="sdrDeviceStatus">Not connected</span>
            </div>

            <div class="form-group">
                <label>COM Port / Device
                    <button class="btn btn-primary" onclick="loadComPorts()" style="font-size:0.7rem; padding:2px 8px; margin-left:8px;">
                        <i class="fas fa-sync-alt"></i> Load ports
                    </button>
                    <button class="btn btn-warning" onclick="detectRTLSDR()" style="font-size:0.7rem; padding:2px 8px; margin-left:4px;">
                        <i class="fas fa-search"></i> Detect RTL-SDR
                    </button>
                </label>
                <select id="sdrPort">
                    <option value="">-- Select device --</option>
                    <option value="auto">Auto-Detect (rtl_sdr)</option>
                </select>
            </div>

            <div class="form-group">
                <label>Frequency (MHz)</label>
                <input type="number" id="sdrFrequency" value="433.920" step="0.001" min="24" max="1766">
            </div>

            <div class="form-group">
                <label>Sample Rate (MHz)</label>
                <select id="sdrSampleRate">
                    <option value="0.25">0.25 MHz (250 kHz BW)</option>
                    <option value="1.0">1.0 MHz</option>
                    <option value="2.4" selected>2.4 MHz (default)</option>
                    <option value="2.8">2.8 MHz</option>
                </select>
            </div>

            <div class="form-group">
                <label>Gain (dB) &nbsp;<span id="gainLabel" style="color:var(--accent-blue);">20</span></label>
                <input type="range" id="sdrGain" min="0" max="49" step="1" value="20"
                    oninput="document.getElementById('gainLabel').textContent=this.value"
                    style="width:100%; accent-color:var(--accent-blue);">
            </div>

            <div class="form-group">
                <label>Mode</label>
                <select id="sdrMode">
                    <option value="FM">FM</option>
                    <option value="AM">AM</option>
                    <option value="SSB">SSB</option>
                </select>
            </div>

            <div class="form-group">
                <label>Squelch Level (0&ndash;9)</label>
                <select id="sdrSquelch">
                    <option value="0">0 &ndash; Off (-999 dBm)</option>
                    <option value="1">1 &ndash; -85 dBm</option>
                    <option value="2">2 &ndash; -80 dBm</option>
                    <option value="3">3 &ndash; -75 dBm</option>
                    <option value="4">4 &ndash; -70 dBm</option>
                    <option value="5">5 &ndash; -65 dBm</option>
                    <option value="6">6 &ndash; -60 dBm</option>
                    <option value="7">7 &ndash; -55 dBm</option>
                    <option value="8">8 &ndash; -50 dBm</option>
                    <option value="9">9 &ndash; -45 dBm</option>
                </select>
            </div>

            <div class="form-group">
                <label>TX Power Reference (dBm)</label>
                <input type="number" id="sdrTxPower" value="20" step="1">
            </div>

            <div class="btn-row">
                <button class="btn btn-primary" onclick="connectSDR()"><i class="fas fa-plug"></i> Connect</button>
                <button class="btn btn-success" id="btnMeasure" onclick="startMeasurement()"><i class="fas fa-search"></i> Measure</button>
                <button class="btn btn-warning" id="btnScan" onclick="toggleContinuousScan()"><i class="fas fa-play"></i> Scan</button>
            </div>
        </div>

        <!-- Signal Analysis -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title"><i class="fas fa-wave-square"></i> Signal Analysis</div>
                <div style="display:flex; align-items:center; gap:8px; font-size:0.8rem; color:var(--text-dim);">
                    <label>Min dBm <input type="number" id="scaleMin" value="-120" style="width:60px; padding:2px 5px; background:var(--panel-input-bg); border:1px solid var(--border-color); border-radius:3px; color:var(--text-main); font-size:0.8rem;"></label>
                    <label>Max dBm <input type="number" id="scaleMax" value="-10"  style="width:55px; padding:2px 5px; background:var(--panel-input-bg); border:1px solid var(--border-color); border-radius:3px; color:var(--text-main); font-size:0.8rem;"></label>
                </div>
            </div>

            <!-- Combined Spectrum + Waterfall display -->
            <div class="sdr-display-wrap" id="sdrDisplayWrap">
                <span class="sdr-mode-badge" id="sdrModeBadge">LIVE</span>

                <!-- Spectrum canvas (FFT line plot) -->
                <canvas id="spectrumCanvas" height="180"></canvas>

                <!-- Frequency axis between spectrum and waterfall -->
                <div class="sdr-freq-axis" id="freqAxis">
                    <span id="fa0">—</span><span id="fa1">—</span><span id="fa2">—</span>
                    <span id="fa3">—</span><span id="fa4">—</span><span id="fa5">—</span>
                </div>

                <!-- Waterfall canvas (scrolling color display) -->
                <div class="sdr-wf-label">&#9660; Waterfall (newest row = top)</div>
                <canvas id="waterfallCanvas" height="200"></canvas>

                <!-- Colorscale bar -->
                <div class="sdr-colorscale"></div>
            </div>

            <!-- Signal meter -->
            <label style="font-size:0.85rem; color:var(--text-dim);">Signal Strength</label>
            <div class="signal-meter">
                <div class="signal-bar-container">
                    <div class="signal-bar" id="signalBar"></div>
                </div>
                <div class="signal-value" id="signalValue">-- dBm</div>
            </div>

            <label style="font-size:0.85rem; color:var(--text-dim);">Estimated Distance</label>
            <div class="signal-meter">
                <div class="signal-bar-container">
                    <div class="signal-bar" id="distanceBar" style="background: linear-gradient(90deg, #2ecc71, #f39c12, #e74c3c);"></div>
                </div>
                <div class="signal-value" id="distanceValue">-- m</div>
            </div>

            <div style="margin-top:15px; padding:10px; background:#111; border-radius:4px; font-size:0.8rem; color:var(--text-dim);">
                <div><strong>Model:</strong> Log-Distance Path Loss (n=3.0)</div>
                <div><strong>Calibration:</strong> -2.5 dBm Offset</div>
                <div><strong>Bandpass:</strong> 10&ndash;30 kHz, Butterworth 4th Order</div>
                <div><strong>Averaging:</strong> 5 measurements</div>
            </div>
        </div>
    </div>

    <!-- Bottom panels -->
    <div class="panel-grid">
        <!-- MQTT / Triangulation -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title"><i class="fas fa-project-diagram"></i> Cross-Bearing / Triangulation</div>
                <span class="status-badge status-offline" id="mqttStatus">MQTT Offline</span>
            </div>

            <div class="form-group">
                <label>MQTT Broker</label>
                <input type="text" id="mqttHost" value="localhost" placeholder="e.g. 192.168.8.181">
            </div>

            <div class="form-group">
                <label>MQTT Port</label>
                <input type="number" id="mqttPort" value="1883">
            </div>

            <div class="form-group">
                <label>MQTT Topic</label>
                <input type="text" id="mqttTopic" value="lpu5/signal" placeholder="lpu5/signal">
            </div>

            <div class="btn-row">
                <button class="btn btn-primary" onclick="connectMQTT()"><i class="fas fa-link"></i> MQTT Connect</button>
                <button class="btn btn-success" onclick="triangulate()"><i class="fas fa-crosshairs"></i> Triangulate</button>
            </div>

            <div style="margin-top:15px;">
                <label style="font-size:0.85rem; color:var(--text-dim);">Connected Peers</label>
                <div class="mqtt-peers" id="mqttPeers">
                    <span style="color:var(--text-dim); font-size:0.8rem;">No peers connected</span>
                </div>
            </div>

            <!-- Triangulation map -->
            <div style="margin-top:15px;">
                <label style="font-size:0.85rem; color:var(--text-dim);">Triangulation Map</label>
                <div class="map-placeholder" id="triangulationMap">
                    <i class="fas fa-map-marked-alt"></i>
                    <span>Map will be shown after triangulation</span>
                    <span style="font-size:0.75rem;">At least 2 peers required</span>
                </div>
            </div>
        </div>

        <!-- Measurement Log -->
        <div class="panel">
            <div class="panel-header">
                <div class="panel-title"><i class="fas fa-clipboard-list"></i> Measurement Log</div>
                <button class="btn btn-danger" onclick="clearLog()" style="font-size:0.75rem; padding:4px 8px;">
                    <i class="fas fa-trash"></i> Delete
                </button>
            </div>

            <div class="log-container" id="logContainer">
                <table>
                    <thead>
                        <tr>
                            <th>Time</th>
                            <th>Freq (MHz)</th>
                            <th>Mode</th>
                            <th>Signal (dBm)</th>
                            <th>Distance</th>
                            <th>Source</th>
                        </tr>
                    </thead>
                    <tbody id="logBody">
                        <tr>
                            <td colspan="6" style="text-align:center; color:var(--text-dim);">
                                No measurements taken yet
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div style="margin-top:15px;">
                <button class="btn btn-primary" onclick="exportLog()"><i class="fas fa-download"></i> CSV Export</button>
            </div>
        </div>
    </div>

    <!-- Audio Output Panel -->
    <div class="panel" style="margin-top:16px;">
        <div class="panel-header">
            <div class="panel-title"><i class="fas fa-volume-up"></i> Audio Output</div>
            <span class="status-badge status-offline" id="audioStatus">Audio Off</span>
        </div>
        <div style="display:flex; flex-wrap:wrap; align-items:center; gap:12px; margin-top:8px;">
            <button class="btn btn-primary" id="audioToggleBtn" onclick="toggleAudio()">
                <i class="fas fa-play"></i> Enable Audio
            </button>
            <button class="btn btn-warning" id="muteBtn" onclick="toggleMute()" disabled>
                <i class="fas fa-volume-mute"></i> Mute
            </button>
            <div style="display:flex; align-items:center; gap:8px; flex:1; min-width:160px;">
                <i class="fas fa-volume-down" style="color:var(--text-dim);"></i>
                <input type="range" id="audioVolume" min="0" max="100" value="70"
                    oninput="setAudioVolume(this.value)"
                    style="flex:1; accent-color:var(--accent-blue);">
                <i class="fas fa-volume-up" style="color:var(--text-dim);"></i>
                <span id="audioVolumeLabel" style="color:var(--accent-blue); min-width:36px; text-align:right;">70%</span>
            </div>
        </div>
        <div style="margin-top:10px; font-size:0.8rem; color:var(--text-dim);">
            <i class="fas fa-info-circle"></i>
            Streams demodulated audio from SDR hardware via <code>rtl_fm</code> or pyrtlsdr.
            Requires a connected RTL-SDR device; returns an error if no hardware is available.
        </div>
        <!-- Hidden audio element for hardware streaming -->
        <audio id="sdrAudioEl" preload="none" style="display:none;"></audio>
    </div>
</div>

<script>
(function() {
    'use strict';

    // =====================================================================
    // State
    // =====================================================================
    let sdrConnected   = false;
    let sdrMode        = 'hardware'; // hardware only
    let mqttConnected  = false;
    let continuousScan = false;
    let scanTimer      = null;
    const measurementLog = [];
    const mqttPeers    = {};
    let ws             = null;

    // =====================================================================
    // Audio Output State
    // =====================================================================
    let audioCtx         = null;
    let audioGain        = null;  // master gain node
    let audioOsc         = null;  // oscillator node (simulation fallback)
    let audioEl          = document.getElementById('sdrAudioEl');  // <audio> element for hardware streaming
    let audioEnabled     = false;
    let audioMuted       = false;
    let audioVolume      = 0.70;  // 0..1

    function _initAudio() {
        if (audioCtx) return; // already initialised
        try {
            audioCtx  = new (window.AudioContext || window.webkitAudioContext)();
            audioGain = audioCtx.createGain();
            audioGain.gain.value = 0;          // start silent
            audioGain.connect(audioCtx.destination);

            audioOsc = audioCtx.createOscillator();
            audioOsc.type      = 'sine';
            audioOsc.frequency.value = 800;    // default 800 Hz tone
            audioOsc.connect(audioGain);
            audioOsc.start();
        } catch (e) {
            console.error('[SDR] AudioContext init failed:', e);
        }
    }

    /** Start real audio stream from /api/sdr/audio (hardware mode). */
    function _startAudioStream() {
        if (!audioEl) return;
        var freq = parseFloat(document.getElementById('sdrFrequency').value) || 433.920;
        var mode = (document.getElementById('sdrMode').value || 'fm').toLowerCase();
        var gain = parseFloat(document.getElementById('sdrGain').value) || 20;
        var sq   = parseInt(document.getElementById('sdrSquelch').value) || 0;
        var url  = '/api/sdr/audio?frequency_mhz=' + freq +
                   '&mode=' + encodeURIComponent(mode) +
                   '&sample_rate=200000&audio_rate=48000' +
                   '&gain=' + gain + '&squelch=' + sq;
        audioEl.onerror = function() {
            var statusEl = document.getElementById('audioStatus');
            if (statusEl) {
                statusEl.textContent = 'No Hardware';
                statusEl.className   = 'status-badge status-offline';
            }
            console.warn('[SDR] Audio stream unavailable — no SDR hardware detected.');
        };
        audioEl.src    = url;
        audioEl.volume = audioMuted ? 0 : audioVolume;
        audioEl.play().catch(function(e) { console.error('[SDR] Audio stream error:', e); });
    }

    /** Stop real audio stream. */
    function _stopAudioStream() {
        if (!audioEl) return;
        audioEl.onerror = null;
        audioEl.pause();
        audioEl.removeAttribute('src');
        audioEl.load();
    }

    window.toggleAudio = function() {
        audioEnabled = !audioEnabled;
        var btn       = document.getElementById('audioToggleBtn');
        var muteBtn   = document.getElementById('muteBtn');
        var statusEl  = document.getElementById('audioStatus');

        if (audioEnabled) {
            _startAudioStream();
            btn.innerHTML  = '<i class="fas fa-stop"></i> Disable Audio';
            btn.className  = 'btn btn-danger';
            muteBtn.disabled = false;
            statusEl.textContent = audioMuted ? 'Muted' : 'Audio On';
            statusEl.className   = 'status-badge status-' + (audioMuted ? 'waiting' : 'online');
        } else {
            _stopAudioStream();
            btn.innerHTML  = '<i class="fas fa-play"></i> Enable Audio';
            btn.className  = 'btn btn-primary';
            muteBtn.disabled = true;
            statusEl.textContent = 'Audio Off';
            statusEl.className   = 'status-badge status-offline';
        }
    };

    window.toggleMute = function() {
        audioMuted = !audioMuted;
        var btn      = document.getElementById('muteBtn');
        var statusEl = document.getElementById('audioStatus');

        if (audioMuted) {
            if (audioGain) audioGain.gain.value = 0;
            if (audioEl)   audioEl.volume = 0;
            btn.innerHTML = '<i class="fas fa-volume-mute"></i> Unmute';
            btn.className = 'btn btn-success';
            statusEl.textContent = 'Muted';
            statusEl.className   = 'status-badge status-waiting';
        } else {
            if (audioEl) audioEl.volume = audioVolume;
            btn.innerHTML = '<i class="fas fa-volume-mute"></i> Mute';
            btn.className = 'btn btn-warning';
            statusEl.textContent = 'Audio On';
            statusEl.className   = 'status-badge status-online';
        }
    };

    window.setAudioVolume = function(val) {
        audioVolume = val / 100;
        document.getElementById('audioVolumeLabel').textContent = val + '%';
        if (audioEl && !audioMuted) audioEl.volume = audioVolume;
        // Oscillator volume applied on next _updateAudioTone call
    };

    /**
     * Update synthetic audio tone (simulation fallback only).
     * Only active when sdrMode is not 'hardware'.
     */
    function _updateAudioTone(peakDbm, freqMhz, blocked) {
        // Hardware mode uses the real audio stream; skip oscillator
        if (sdrMode === 'hardware') return;
        if (!audioEnabled || !audioCtx || !audioGain || !audioOsc) return;
        if (audioMuted || blocked) {
            audioGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            return;
        }

        // Map peak power (-100 … -30 dBm) to volume (0 … 1)
        var MIN_DBM  = -100;
        var DBM_RANGE = 70;
        var normLevel  = Math.max(0, Math.min(1, (peakDbm - MIN_DBM) / DBM_RANGE));
        var targetGain = normLevel * audioVolume;

        // Map frequency offset to tone pitch (400 Hz … 1200 Hz)
        var BASE_PITCH_HZ  = 800;
        var PITCH_RANGE_HZ = 400;
        var centerFreq = parseFloat(document.getElementById('sdrFrequency').value) || 433.920;
        var offsetMhz  = freqMhz - centerFreq;
        var maxOffset  = (parseFloat(document.getElementById('sdrSampleRate').value) || 2.4) / 2;
        var normOffset = Math.max(-1, Math.min(1, offsetMhz / maxOffset));
        var pitch      = BASE_PITCH_HZ + normOffset * PITCH_RANGE_HZ; // 400–1200 Hz

        audioOsc.frequency.setTargetAtTime(pitch, audioCtx.currentTime, 0.05);
        audioGain.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.05);
    }

    // Display range (dBm)
    function getScaleMin() { return parseFloat(document.getElementById('scaleMin').value) || -120; }
    function getScaleMax() { return parseFloat(document.getElementById('scaleMax').value) || -10; }

    // =====================================================================
    // Canvas references
    // =====================================================================
    const spCanvas = document.getElementById('spectrumCanvas');
    const spCtx    = spCanvas ? spCanvas.getContext('2d') : null;
    const wfCanvas = document.getElementById('waterfallCanvas');
    const wfCtx    = wfCanvas ? wfCanvas.getContext('2d') : null;

    // =====================================================================
    // GQRX colour map  (black→dark-blue→blue→cyan→green→yellow→orange→red)
    // =====================================================================
    var COLOR_STOPS = [
        [0.00,   0,   0,  64],
        [0.15,   0,   0, 180],
        [0.30,   0,  80, 200],
        [0.45,   0, 200, 200],
        [0.60,   0, 200,   0],
        [0.75, 200, 200,   0],
        [0.88, 255, 120,   0],
        [1.00, 255,   0,   0],
    ];

    function dbmToColor(dbm) {
        var mn = getScaleMin(), mx = getScaleMax();
        var t = Math.max(0, Math.min(1, (dbm - mn) / (mx - mn)));
        for (var i = 1; i < COLOR_STOPS.length; i++) {
            if (t <= COLOR_STOPS[i][0]) {
                var a = COLOR_STOPS[i-1], b = COLOR_STOPS[i];
                var f = (t - a[0]) / (b[0] - a[0]);
                return [
                    Math.round(a[1] + f * (b[1] - a[1])),
                    Math.round(a[2] + f * (b[2] - a[2])),
                    Math.round(a[3] + f * (b[3] - a[3]))
                ];
            }
        }
        return [255, 0, 0];
    }

    // =====================================================================
    // Canvas init / resize
    // =====================================================================
    function initCanvases() {
        var wrap = document.getElementById('sdrDisplayWrap');
        var w    = wrap ? wrap.clientWidth : 600;
        if (spCanvas) {
            spCanvas.width  = w;
            spCanvas.height = 180;
            clearSpectrum();
        }
        if (wfCanvas) {
            wfCanvas.width  = w;
            wfCanvas.height = 200;
            clearWaterfall();
        }
    }

    function clearSpectrum() {
        if (!spCtx) return;
        spCtx.fillStyle = '#000';
        spCtx.fillRect(0, 0, spCanvas.width, spCanvas.height);
        drawSpectrumGrid(null, null);
    }

    function clearWaterfall() {
        if (!wfCtx) return;
        wfCtx.fillStyle = '#000';
        wfCtx.fillRect(0, 0, wfCanvas.width, wfCanvas.height);
    }

    // =====================================================================
    // Spectrum plot (line graph + grid + dBm axis)
    // Caches the last data so the crosshair tooltip can redraw it.
    // =====================================================================
    var _lastSpectrum = null;
    var _lastFStart   = null;
    var _lastFEnd     = null;

    function drawSpectrumGrid(freqStartMhz, freqEndMhz) {
        if (!spCtx) return;
        var W = spCanvas.width, H = spCanvas.height;
        var mn = getScaleMin(), mx = getScaleMax();

        // Grid lines
        spCtx.strokeStyle = '#1c1c1c';
        spCtx.lineWidth   = 1;
        var nH = 6, nV = 8;
        for (var i = 0; i <= nH; i++) {
            var y = Math.round(i * H / nH);
            spCtx.beginPath(); spCtx.moveTo(0, y); spCtx.lineTo(W, y); spCtx.stroke();
        }
        for (var j = 0; j <= nV; j++) {
            var x = Math.round(j * W / nV);
            spCtx.beginPath(); spCtx.moveTo(x, 0); spCtx.lineTo(x, H); spCtx.stroke();
        }

        // dBm axis labels (right side)
        spCtx.fillStyle    = '#555';
        spCtx.font         = '10px Courier New';
        spCtx.textAlign    = 'right';
        for (var k = 0; k <= nH; k++) {
            var dbm = mx - k * (mx - mn) / nH;
            var yy  = Math.round(k * H / nH);
            spCtx.fillText(dbm.toFixed(0) + ' dBm', W - 2, yy + 11);
        }
        spCtx.textAlign = 'left';

        // Title
        if (freqStartMhz !== null) {
            spCtx.fillStyle = '#444';
            spCtx.font      = '10px Courier New';
            spCtx.fillText('Spectrum', 4, 12);
        }
    }

    function renderSpectrum(fftData, freqStartMhz, freqEndMhz) {
        if (!spCtx || !fftData || !fftData.length) return;
        // Cache for crosshair redraw
        _lastSpectrum = fftData;
        _lastFStart   = freqStartMhz;
        _lastFEnd     = freqEndMhz;
        var W = spCanvas.width, H = spCanvas.height;
        var mn = getScaleMin(), mx = getScaleMax();

        // Clear + grid
        spCtx.fillStyle = '#000';
        spCtx.fillRect(0, 0, W, H);
        drawSpectrumGrid(freqStartMhz, freqEndMhz);

        // Peak hold (filled area under curve) — dark green
        spCtx.beginPath();
        for (var x = 0; x < W; x++) {
            var idx  = Math.floor(x * fftData.length / W);
            var dbm  = fftData[idx];
            var y    = H - Math.max(0, Math.min(1, (dbm - mn) / (mx - mn))) * H;
            if (x === 0) spCtx.moveTo(x, y); else spCtx.lineTo(x, y);
        }
        spCtx.lineTo(W, H); spCtx.lineTo(0, H); spCtx.closePath();
        spCtx.fillStyle = 'rgba(0,120,40,0.35)';
        spCtx.fill();

        // Main FFT curve — bright green
        spCtx.beginPath();
        spCtx.strokeStyle = '#2ecc71';
        spCtx.lineWidth   = 1.2;
        for (var x2 = 0; x2 < W; x2++) {
            var idx2 = Math.floor(x2 * fftData.length / W);
            var dbm2 = fftData[idx2];
            var y2   = H - Math.max(0, Math.min(1, (dbm2 - mn) / (mx - mn))) * H;
            if (x2 === 0) spCtx.moveTo(x2, y2); else spCtx.lineTo(x2, y2);
        }
        spCtx.stroke();

        // Update frequency axis labels
        updateFreqAxis(freqStartMhz, freqEndMhz);
    }

    function updateFreqAxis(fStart, fEnd) {
        if (fStart === null || fStart === undefined) return;
        var ids = ['fa0','fa1','fa2','fa3','fa4','fa5'];
        for (var i = 0; i < ids.length; i++) {
            var el = document.getElementById(ids[i]);
            if (!el) continue;
            var f = fStart + (fEnd - fStart) * i / (ids.length - 1);
            el.textContent = f.toFixed(3) + ' MHz';
        }
    }

    // =====================================================================
    // Waterfall rendering (GQRX-style scrolling colour display)
    // =====================================================================
    function renderWaterfallRow(fftData) {
        if (!wfCtx || !fftData || !fftData.length) return;
        var W = wfCanvas.width, H = wfCanvas.height;

        // Shift existing content down by 1 pixel
        var img = wfCtx.getImageData(0, 0, W, H - 1);
        wfCtx.putImageData(img, 0, 1);

        // Draw new row at top
        var row = wfCtx.createImageData(W, 1);
        var d   = row.data;
        for (var x = 0; x < W; x++) {
            var idx = Math.floor(x * fftData.length / W);
            var rgb = dbmToColor(fftData[idx]);
            var p   = x * 4;
            d[p]   = rgb[0];
            d[p+1] = rgb[1];
            d[p+2] = rgb[2];
            d[p+3] = 255;
        }
        wfCtx.putImageData(row, 0, 0);
    }

    // =====================================================================
    // Mode badge
    // =====================================================================
    function setModeBadge(mode) {
        var badge = document.getElementById('sdrModeBadge');
        if (!badge) return;
        badge.textContent = 'LIVE';
        badge.className   = 'sdr-mode-badge';
    }

    // =====================================================================
    // Load COM ports (serial scan)
    // =====================================================================
    window.loadComPorts = function() {
        var select  = document.getElementById('sdrPort');
        var token   = localStorage.getItem('token');
        var headers = {};
        if (token) headers['Authorization'] = 'Bearer ' + token;

        fetch('/api/scan_ports', { headers: headers })
        .then(function(res) { return res.json(); })
        .then(function(ports) {
            while (select.options.length > 2) select.remove(2);
            if (Array.isArray(ports) && ports.length > 0) {
                ports.forEach(function(p) {
                    var opt   = document.createElement('option');
                    opt.value = p.device;
                    var label = p.device;
                    if (p.description && p.description !== p.device) label += ' - ' + p.description;
                    if (p.manufacturer) label += ' [' + p.manufacturer + ']';
                    opt.textContent = label;
                    select.appendChild(opt);
                });
            } else {
                var opt       = document.createElement('option');
                opt.value     = '';
                opt.disabled  = true;
                opt.textContent = '(no serial ports found)';
                select.appendChild(opt);
            }
        })
        .catch(function(e) { console.error('loadComPorts failed:', e); });
    };

    // =====================================================================
    // Detect RTL-SDR via dedicated backend endpoint
    // =====================================================================
    window.detectRTLSDR = function() {
        var select  = document.getElementById('sdrPort');
        var statusEl = document.getElementById('sdrDeviceStatus');
        statusEl.textContent = 'Scanning…';
        statusEl.className   = 'status-badge status-waiting';

        fetch('/api/sdr/devices')
        .then(function(r) { return r.json(); })
        .then(function(data) {
            var devices = data.devices || [];
            // Remove existing RTL-SDR entries
            for (var i = select.options.length - 1; i >= 2; i--) {
                if (select.options[i].dataset.rtlsdr) select.remove(i);
            }
            if (devices.length === 0) {
                statusEl.textContent = 'No RTL-SDR found';
                statusEl.className   = 'status-badge status-offline';
            } else {
                devices.forEach(function(dev, idx) {
                    var opt = document.createElement('option');
                    opt.value = 'rtlsdr:' + (dev.index || idx);
                    opt.textContent = dev.name || ('RTL-SDR #' + idx);
                    opt.dataset.rtlsdr = '1';
                    select.appendChild(opt);
                });
                select.value = 'rtlsdr:0';
                statusEl.textContent = devices.length + ' RTL-SDR device(s) found';
                statusEl.className   = 'status-badge status-online';
            }

            // Show capabilities in console
            var caps = data.capabilities || {};
            console.log('[SDR] Capabilities:', caps);
        })
        .catch(function(e) {
            console.error('detectRTLSDR failed:', e);
            statusEl.textContent = 'Scan failed';
            statusEl.className   = 'status-badge status-offline';
        });
    };

    // =====================================================================
    // Connect to SDR (real API call)
    // =====================================================================
    window.connectSDR = function() {
        var port = document.getElementById('sdrPort').value;
        if (!port) {
            alert('Please select an SDR device / COM port');
            return;
        }
        var statusEl   = document.getElementById('sdrDeviceStatus');
        var mainStatus = document.getElementById('sdrStatus');
        statusEl.textContent = 'Connecting…';
        statusEl.className   = 'status-badge status-waiting';

        var freq    = parseFloat(document.getElementById('sdrFrequency').value) || 433.920;
        var sr      = parseFloat(document.getElementById('sdrSampleRate').value) || 2.4;
        var gain    = parseFloat(document.getElementById('sdrGain').value)       || 20;

        fetch('/api/sdr/connect', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                device_index:    0,
                frequency_mhz:   freq,
                sample_rate_mhz: sr,
                gain:            gain
            })
        })
        .then(function(r) { return r.json(); })
        .then(function(data) {
            sdrConnected = true;
            sdrMode      = data.mode || 'hardware';

            statusEl.textContent = 'Connected (HW)';
            statusEl.className   = 'status-badge status-online';
            mainStatus.innerHTML = '<i class="fas fa-circle"></i> SDR Active (HW)';
            mainStatus.className = 'status-badge status-online';

            setModeBadge(sdrMode);
            console.log('[SDR] Connected — mode:', sdrMode, 'devices:', data.devices);
        })
        .catch(function(e) {
            console.error('[SDR] connect failed:', e);
            statusEl.textContent = 'Connection failed';
            statusEl.className   = 'status-badge status-offline';
            mainStatus.innerHTML = '<i class="fas fa-circle"></i> SDR Offline';
            mainStatus.className = 'status-badge status-offline';
        });
    };

    // =====================================================================
    // Single measurement — calls /api/sdr/measure, renders waterfall row
    // =====================================================================
    window.startMeasurement = function() {
        if (!sdrConnected) {
            alert('Please connect SDR device first');
            return;
        }
        _doMeasurement();
    };

    function _doMeasurement() {
        var freq = parseFloat(document.getElementById('sdrFrequency').value) || 433.920;
        var sr   = parseFloat(document.getElementById('sdrSampleRate').value) || 2.4;
        var gain = parseFloat(document.getElementById('sdrGain').value)       || 20;
        var mode = document.getElementById('sdrMode').value;
        var sq   = parseInt(document.getElementById('sdrSquelch').value) || 0;

        fetch('/api/sdr/measure', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                frequency_mhz:   freq,
                sample_rate_mhz: sr,
                gain:            gain,
                nfft:            1024
            })
        })
        .then(function(r) { return r.json(); })
        .then(function(data) {
            var spectrum   = data.spectrum  || [];
            var fStart     = data.freq_start_mhz;
            var fEnd       = data.freq_end_mhz;
            var source     = data.source    || 'hardware';

            setModeBadge(source);

            if (!spectrum.length) return;

            // Find peak power
            var peak = spectrum.reduce(function(a, b) { return a > b ? a : b; }, -Infinity);

            // Apply squelch
            var sqThresholds = [-999, -85, -80, -75, -70, -65, -60, -55, -50, -45];
            var threshold    = sqThresholds[Math.min(Math.max(sq, 0), 9)];
            var blocked      = peak < threshold;

            // Render spectrum + waterfall
            renderSpectrum(spectrum, fStart, fEnd);
            renderWaterfallRow(spectrum);

            // Update meters
            var distance = blocked ? null : estimateDistance(peak, freq);
            updateSignalDisplay(peak, distance, blocked);

            // Update audio tone
            _updateAudioTone(peak, freq, blocked);

            // Log entry
            var distStr = blocked ? 'squelch' : (distance !== null ? distance.toFixed(1) + ' m' : '--');
            addLogEntry(freq, mode, peak, distStr, source === 'rtl_power' ? 'CLI' : 'HW');
        })
        .catch(function(e) {
            console.error('[SDR] measure failed:', e);
        });
    }

    // =====================================================================
    // Continuous scan (toggle Start / Stop)
    // =====================================================================
    window.toggleContinuousScan = function() {
        if (!sdrConnected) {
            alert('Please connect SDR device first');
            return;
        }
        var btn = document.getElementById('btnScan');
        if (continuousScan) {
            // Stop
            continuousScan = false;
            if (scanTimer !== null) { clearInterval(scanTimer); scanTimer = null; }
            btn.innerHTML = '<i class="fas fa-play"></i> Scan';
            btn.className = 'btn btn-warning';
        } else {
            // Start
            continuousScan = true;
            btn.innerHTML = '<i class="fas fa-stop"></i> Stop';
            btn.className = 'btn btn-danger';
            _doMeasurement();
            scanTimer = setInterval(_doMeasurement, 600);
        }
    };

    // =====================================================================
    // Synchronized measurement (broadcasts via WebSocket then measures locally)
    // =====================================================================
    window.startSyncMeasurement = function() {
        if (!sdrConnected) {
            alert('Please connect SDR device first');
            return;
        }
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type:      'sdr_sync_request',
                frequency: parseFloat(document.getElementById('sdrFrequency').value),
                mode:      document.getElementById('sdrMode').value
            }));
        }
        window.startMeasurement();
    };

    // =====================================================================
    // MQTT Connection
    // =====================================================================
    window.connectMQTT = function() {
        var host     = document.getElementById('mqttHost').value;
        var port     = document.getElementById('mqttPort').value;
        var statusEl = document.getElementById('mqttStatus');
        statusEl.textContent = 'Connecting…';
        statusEl.className   = 'status-badge status-waiting';
        // Actual MQTT connection would require backend relay; placeholder kept intentional
        setTimeout(function() {
            mqttConnected        = true;
            statusEl.textContent = 'MQTT Online';
            statusEl.className   = 'status-badge status-online';
            console.log('[SDR] MQTT target:', host + ':' + port);
        }, 1000);
    };

    // =====================================================================
    // Triangulation
    // =====================================================================
    window.triangulate = function() {
        var peerCount = Object.keys(mqttPeers).length;
        if (peerCount < 2) {
            alert('At least 2 connected peers needed for triangulation.\nCurrent: ' + peerCount + ' Peer(s)');
            return;
        }
        var mapEl = document.getElementById('triangulationMap');
        mapEl.innerHTML = '<i class="fas fa-crosshairs" style="color:var(--accent-blue);"></i><span>Calculating…</span>';
        setTimeout(function() {
            mapEl.innerHTML = '<i class="fas fa-map-marked-alt" style="color:var(--accent);"></i>' +
                '<span>Estimated position calculated</span>' +
                '<span style="font-size:0.85rem; color:var(--accent);">Show result on Tactical Map</span>';
        }, 2000);
    };

    // =====================================================================
    // WebSocket connection (for SDR peer sync)
    // =====================================================================
    function connectWebSocket() {
        var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        var wsUrl    = protocol + '//' + window.location.host + '/ws';
        try {
            ws = new WebSocket(wsUrl);
            ws.onopen = function() {
                ws.send(JSON.stringify({ type: 'subscribe', channel: 'sdr' }));
            };
            ws.onmessage = function(event) {
                try {
                    var data = JSON.parse(event.data);
                    if (data.type === 'sdr_measurement') handleRemoteMeasurement(data);
                    else if (data.type === 'sdr_peer_update') handlePeerUpdate(data);
                } catch (e) { /* ignore */ }
            };
            ws.onclose = function() { ws = null; setTimeout(connectWebSocket, 5000); };
        } catch (e) { console.error('[SDR] WebSocket failed:', e); }
    }

    // =====================================================================
    // Helpers
    // =====================================================================
    function estimateDistance(rssiDbm, freqMhz) {
        var txPower = parseFloat(document.getElementById('sdrTxPower').value) || 20;
        var c       = 299792458;
        var freqHz  = freqMhz * 1e6;
        var refRssi = txPower - (20 * Math.log10(4 * Math.PI * 1 * freqHz / c));
        return Math.pow(10, (refRssi - rssiDbm) / (10 * 3.0));
    }

    function updateSignalDisplay(power, distance, blocked) {
        var pct       = Math.max(0, Math.min(100, (power + 100) * 2));
        var signalBar = document.getElementById('signalBar');
        var signalVal = document.getElementById('signalValue');
        var distBar   = document.getElementById('distanceBar');
        var distVal   = document.getElementById('distanceValue');

        if (signalBar) signalBar.style.width = pct + '%';
        if (signalVal) signalVal.textContent  = blocked
            ? power.toFixed(1) + ' dBm (squelch)'
            : power.toFixed(1) + ' dBm';

        if (distance !== null && !blocked) {
            var dPct = Math.max(0, Math.min(100, Math.log10(distance + 1) * 25));
            if (distBar) distBar.style.width  = dPct + '%';
            if (distVal) distVal.textContent  = distance.toFixed(1) + ' m';
        } else {
            if (distBar) distBar.style.width  = '0%';
            if (distVal) distVal.textContent  = '-- no signal --';
        }
    }

    function addLogEntry(freq, mode, power, distance, source) {
        var ts = new Date().toLocaleTimeString('en-US');
        source = source || 'HW';
        measurementLog.push({ time: ts, freq: freq, mode: mode, power: power, distance: distance, source: source });
        var tbody = document.getElementById('logBody');
        if (measurementLog.length === 1) tbody.innerHTML = '';
        var srcColor = '#2ecc71';
        var tr = document.createElement('tr');
        tr.innerHTML = '<td>' + ts + '</td>' +
            '<td>' + freq.toFixed(3) + '</td>' +
            '<td>' + mode + '</td>' +
            '<td>' + (typeof power === 'number' ? power.toFixed(1) : power) + '</td>' +
            '<td>' + distance + '</td>' +
            '<td style="color:' + srcColor + '; font-weight:bold;">' + source + '</td>';
        tbody.insertBefore(tr, tbody.firstChild);
    }

    function handleRemoteMeasurement(data) {
        var sender = data.sender || 'unknown';
        if (data.distance && data.lat && data.lon) {
            mqttPeers[sender] = { lat: data.lat, lon: data.lon, distance: data.distance, ts: Date.now() };
            updatePeerDisplay();
        }
    }

    function handlePeerUpdate(data) {
        if (data.peers) { Object.assign(mqttPeers, data.peers); updatePeerDisplay(); }
    }

    function updatePeerDisplay() {
        var container = document.getElementById('mqttPeers');
        var keys      = Object.keys(mqttPeers);
        if (!keys.length) {
            container.innerHTML = '<span style="color:var(--text-dim); font-size:0.8rem;">No peers connected</span>';
            return;
        }
        container.innerHTML = '';
        keys.forEach(function(k) {
            var span       = document.createElement('span');
            span.className = 'peer-badge';
            span.textContent = k + ' (' + (mqttPeers[k].distance || '?') + 'm)';
            container.appendChild(span);
        });
    }

    window.clearLog = function() {
        measurementLog.length = 0;
        document.getElementById('logBody').innerHTML =
            '<tr><td colspan="6" style="text-align:center; color:var(--text-dim);">No measurements taken yet</td></tr>';
    };

    window.exportLog = function() {
        if (!measurementLog.length) { alert('No measurements to export.'); return; }
        var csv = 'Time,Frequency_MHz,Mode,Signal_dBm,Distance,Source\n';
        measurementLog.forEach(function(e) {
            csv += e.time + ',' + e.freq + ',' + e.mode + ',' +
                (typeof e.power === 'number' ? e.power.toFixed(2) : e.power) + ',' +
                e.distance + ',' + (e.source || 'HW') + '\n';
        });
        var a  = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([csv], { type: 'text/csv' }));
        a.download = 'sdr_' + new Date().toISOString().slice(0, 10) + '.csv';
        a.click();
    };

    // =====================================================================
    // Crosshair tooltip on spectrum canvas (shows freq+dBm on hover)
    // =====================================================================
    if (spCanvas) {
        spCanvas.addEventListener('mousemove', function(e) {
            if (!_lastSpectrum || !_lastFStart) return;
            var rect = spCanvas.getBoundingClientRect();
            var mx   = (e.clientX - rect.left) * (spCanvas.width / rect.width);
            var my   = (e.clientY - rect.top)  * (spCanvas.height / rect.height);
            var idx  = Math.floor(mx * _lastSpectrum.length / spCanvas.width);
            var dbm  = _lastSpectrum[Math.min(idx, _lastSpectrum.length - 1)];
            var freq = _lastFStart + (_lastFEnd - _lastFStart) * mx / spCanvas.width;

            // Draw crosshair overlay on top of the cached spectrum
            renderSpectrum(_lastSpectrum, _lastFStart, _lastFEnd);
            spCtx.strokeStyle = 'rgba(255,255,255,0.4)';
            spCtx.lineWidth   = 1;
            spCtx.setLineDash([3, 4]);
            spCtx.beginPath(); spCtx.moveTo(mx, 0); spCtx.lineTo(mx, spCanvas.height); spCtx.stroke();
            spCtx.setLineDash([]);

            // Tooltip label
            spCtx.fillStyle = 'rgba(0,0,0,0.7)';
            spCtx.fillRect(mx + 5, my - 28, 130, 22);
            spCtx.fillStyle = '#2ecc71';
            spCtx.font      = '10px Courier New';
            spCtx.fillText(freq.toFixed(4) + ' MHz  ' + dbm.toFixed(1) + ' dBm', mx + 8, my - 12);
        });

        spCanvas.addEventListener('mouseleave', function() {
            if (_lastSpectrum) renderSpectrum(_lastSpectrum, _lastFStart, _lastFEnd);
        });
    }

    // =====================================================================
    // Init
    // =====================================================================
    window.addEventListener('DOMContentLoaded', function() {
        initCanvases();
        connectWebSocket();
        loadComPorts();
        // Auto-detect RTL-SDR on load
        detectRTLSDR();
    });

    window.addEventListener('resize', function() {
        initCanvases();
        if (_lastSpectrum) renderSpectrum(_lastSpectrum, _lastFStart, _lastFEnd);
    });

})();
</script>

</body>
</html>
